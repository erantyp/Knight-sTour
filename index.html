<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>기사의 모험 (Knight's Tour)</title>
<style>
  :root{
    --board-size: 5; /* stage 1: 5x5, will update via JS */
    --cell: 84px;
    --accent: #14b8a6; /* teal-500 */
    --dark: #101114;
    --light: #fafafa;
    --square-dark: #769656; /* classic chess green */
    --square-light: #eeeed2; /* classic chess tan */
    --visited-shade: rgba(0,0,0,.22);
    --current-glow: 0 0 0 3px #10b981, 0 0 18px #10b98188;
    --legal-glow: 0 0 0 3px #60a5fa, 0 0 14px #60a5fa88;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    color:#e5e7eb; background: radial-gradient(1200px 800px at 20% -10%, #1f2937, #0b0c10);
    display:flex; align-items:center; justify-content:center; padding:24px;
  }
  .app{width:min(100%, 1100px)}
  .topbar{display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:14px}
  .title{font-weight:800; letter-spacing:.2px; font-size:clamp(18px,3vw,26px)}
  .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  button{
    background:#111827; border:1px solid #262b36; color:#e5e7eb; padding:8px 12px; border-radius:10px; cursor:pointer; transition:.15s transform, .15s opacity; font-weight:600
  }
  button:hover{transform:translateY(-1px)}
  button[disabled]{opacity:.45; cursor:not-allowed}
  .pill{padding:6px 10px; border-radius:999px; background:#0b1220; border:1px solid #233047;}
  .hint{opacity:.85; font-size:13px}

  .board-wrap{display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap}
  .board{
    --size: calc(var(--cell) * var(--board-size));
    width:var(--size); height:var(--size);
    display:grid; grid-template-columns: repeat(var(--board-size), var(--cell));
    grid-template-rows: repeat(var(--board-size), var(--cell));
    border-radius:16px; overflow:hidden; box-shadow: 0 10px 40px #00000066;
    border:2px solid #2a2f3a;
  }
  .square{position:relative; display:flex; align-items:center; justify-content:center; user-select:none;}
  .square.light{background:var(--square-light)}
  .square.dark{background:var(--square-dark)}
  /* visited shading */
  .square.visited::after{content:""; position:absolute; inset:0; background:var(--visited-shade)}
  /* current cell glow */
  .square.current{outline: none; box-shadow: var(--current-glow) inset}
  /* legal move highlight */
  .square.legal{outline: none; box-shadow: var(--legal-glow) inset}

  .idx{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:800; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; color:#111; mix-blend-mode:multiply; z-index:1; font-size: clamp(16px, calc(var(--cell)*0.28), 28px)}
  .idx.visited{color:#333; opacity:.8}
  .knight{position:absolute; z-index:2; font-size: clamp(28px, calc(var(--cell)*0.58), 54px); filter: drop-shadow(0 4px 6px rgba(0,0,0,.35));}

  .side{
    flex:1; min-width:260px; background:#0b1220; border:1px solid #1f2a44; border-radius:16px; padding:14px;
  }
  .side h3{margin:.2rem 0 .6rem; font-size:16px}
  .meta{display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:14px}
  .meta div{background:#0e1726; border:1px solid #25324a; padding:8px 10px; border-radius:10px}
  .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; background:#111827; border:1px solid #374151; padding:2px 6px; border-radius:6px}
  .footer{margin-top:10px; font-size:13px; opacity:.85}

  .start{
    position:fixed; inset:0; background: radial-gradient(1000px 700px at 30% -10%, #18212f, #090b0f);
    display:flex; align-items:center; justify-content:center;
  }
  .start-card{background:#0b1220; border:1px solid #1f2a44; border-radius:16px; padding:22px; width:min(92vw, 560px)}
  .start-card h1{margin:0 0 8px; font-size:24px}
  .start-card p{margin:0 0 12px; opacity:.9}
  .stage-select{display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 14px}
  .stage-select button{padding:8px 10px}

  .toast{position:fixed; right:16px; bottom:16px; background:#0b1220; border:1px solid #1f2a44; padding:10px 12px; border-radius:10px; font-size:14px; opacity:0; transform:translateY(8px); transition:.2s}
  .toast.show{opacity:1; transform:translateY(0)}
</style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="title">♞ 기사의 모험 <span class="pill" id="stageLabel">Stage 1 · 5×5</span></div>
      <div class="controls">
        <button id="btnReset">리셋</button>
        <button id="btnUndo">되돌리기</button>
        <button id="btnSolve">힌트/자동완성</button>
        <button id="btnNext" disabled>다음 스테이지 ▶</button>
      </div>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" aria-label="체스판" role="grid"></div>
      <aside class="side">
        <h3>진행 정보</h3>
        <div class="meta">
          <div>방문 수: <b id="moves">0</b></div>
          <div>전체 칸: <b id="total">25</b></div>
          <div>현재 좌표: <b id="coord">-</b></div>
          <div>남은 칸: <b id="left">25</b></div>
        </div>
        <div class="footer">
          먼저 시작 칸을 <b>클릭</b>하세요. 이후에는 ♞ 나이트의 이동 규칙(2칸+1칸 L자)으로만 이동할 수 있어요.<br/><br/>
          이미 방문한 칸은 <b>살짝 어둡게</b> 표시되고, 방문 순서 번호는 <b>중앙</b>에 나타납니다. 가능한 다음 이동은 파란빛 윤곽으로 표시돼요.
          <hr style="border:0; border-top:1px solid #1f2a44; margin:12px 0">
          <b>개발자 치트</b> · <span class="kbd">₩</span> → <span class="kbd">Enter</span> 를 빠르게 누르면 현재 스테이지를 자동 완성합니다.
        </div>
      </aside>
    </div>
  </div>

  <div class="start" id="start">
    <div class="start-card">
      <h1>♞ 기사의 모험</h1>
      <p>나이트의 규칙으로 모든 칸을 한 번씩만 방문하세요. 스테이지는 5×5부터 9×9까지 올라갑니다.</p>
      <div class="stage-select" id="stageButtons"></div>
      <button id="btnStart">게임 시작</button>
      <p class="hint" style="margin-top:10px">팁: 시작 칸을 잘 고르는 것이 중요해요. 막히면 <b>되돌리기</b>를 눌러 이전 칸으로 돌아가세요.</p>
    </div>
  </div>

  <div class="toast" id="toast">치트 활성화! 자동 완성 중…</div>

<script>
(function(){
  // --- Game State ---
  const stages = [5,6,7,8,9];
  let stageIndex = 0; // 0..4
  let N = stages[stageIndex];
  let boardEl = document.getElementById('board');
  let movesEl = document.getElementById('moves');
  let totalEl = document.getElementById('total');
  let leftEl = document.getElementById('left');
  let coordEl = document.getElementById('coord');
  let stageLabel = document.getElementById('stageLabel');
  let btnNext = document.getElementById('btnNext');
  let btnReset = document.getElementById('btnReset');
  let btnUndo  = document.getElementById('btnUndo');
  let btnSolve = document.getElementById('btnSolve');
  const startOverlay = document.getElementById('start');
  const toast = document.getElementById('toast');

  // cheat detector: Backquote (₩ on KR keybd) then Enter within 1.5s
  let cheatArmed = false; let cheatTimer = null;

  const knightMoves = [
    [ 2, 1],[ 2,-1],[-2, 1],[-2,-1],
    [ 1, 2],[ 1,-2],[-1, 2],[-1,-2]
  ];

  let current = null; // {r,c}
  let path = []; // list of {r,c}
  let visited = Array.from({length: N}, () => Array(N).fill(0)); // 0=unvisited, >0 move index

  // --- Utils ---
  const idx = (r,c) => r*N + c;
  const inBounds = (r,c) => r>=0 && c>=0 && r<N && c<N;
  function setCSSVar(name, value){ document.documentElement.style.setProperty(name, value); }
  function showToast(msg){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 1400); }

  function updateHUD(){
    movesEl.textContent = path.length;
    totalEl.textContent = N*N;
    leftEl.textContent = N*N - path.length;
    coordEl.textContent = current ? `(${current.r+1}, ${current.c+1})` : '-';

    // next stage button enable
    btnNext.disabled = (path.length !== N*N);
  }

  // Build stage buttons on start overlay
  const stageButtons = document.getElementById('stageButtons');
  stages.forEach((size, i)=>{
    const b = document.createElement('button');
    b.textContent = `Stage ${i+1} · ${size}×${size}`;
    b.addEventListener('click', ()=>{ stageIndex=i; newGame(); startOverlay.style.display='none'; });
    stageButtons.appendChild(b);
  });
  document.getElementById('btnStart').addEventListener('click', ()=>{ startOverlay.style.display='none'; newGame(); });

  // --- Build Board ---
  function buildBoard(){
    boardEl.innerHTML = '';
    boardEl.style.setProperty('--board-size', N);
    const cellPx = Math.max(60, Math.min(96, Math.floor(760 / N))); // responsive-ish
    setCSSVar('--cell', cellPx+'px');

    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const sq = document.createElement('div');
        sq.className = 'square ' + (((r+c)%2===0)?'light':'dark');
        sq.dataset.r = r; sq.dataset.c = c; sq.role = 'gridcell';

        const idxSpan = document.createElement('div');
        idxSpan.className = 'idx';
        idxSpan.textContent = '';
        sq.appendChild(idxSpan);

        sq.addEventListener('click', onSquareClick);
        boardEl.appendChild(sq);
      }
    }
  }

  function clearBoardDecor(){
    for(const sq of boardEl.children){
      sq.classList.remove('visited','current','legal');
      const idxSpan = sq.querySelector('.idx');
      idxSpan.classList.remove('visited');
      // remove any knight icons
      const k = sq.querySelector('.knight');
      if(k) k.remove();
    }
  }

  function render(){
    clearBoardDecor();

    // visited & numbering
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const n = visited[r][c];
        if(n>0){
          const sq = boardEl.children[idx(r,c)];
          sq.classList.add('visited');
          const idxSpan = sq.querySelector('.idx');
          idxSpan.textContent = n; // centered numbering
          idxSpan.classList.add('visited');
        }
      }
    }

    // current knight
    if(current){
      const sq = boardEl.children[idx(current.r,current.c)];
      sq.classList.add('current');
      const k = document.createElement('div');
      // Use white knight symbol for visibility
      k.className = 'knight';
      k.textContent = '♞';
      sq.appendChild(k);

      // legal moves highlight
      for(const [dr,dc] of knightMoves){
        const nr=current.r+dr, nc=current.c+dc;
        if(inBounds(nr,nc) && !visited[nr][nc]){
          boardEl.children[idx(nr,nc)].classList.add('legal');
        }
      }
    }

    updateHUD();
  }

  function onSquareClick(e){
    const r = +e.currentTarget.dataset.r;
    const c = +e.currentTarget.dataset.c;

    // first click sets the start
    if(!current){
      current = {r,c};
      visited[r][c] = 1;
      path = [{r,c}];
      render();
      return;
    }

    // subsequent clicks must be legal knight moves
    const isLegal = knightMoves.some(([dr,dc])=> current.r+dr===r && current.c+dc===c);
    if(!isLegal || visited[r][c]) return; // ignore illegal or revisits

    current = {r,c};
    visited[r][c] = path.length + 1;
    path.push({r,c});

    render();

    // win check
    if(path.length === N*N){
      showToast(`축하합니다! Stage ${stageIndex+1} 클리어 🎉`);
    }
  }

  function newGame(){
    N = stages[stageIndex];
    visited = Array.from({length: N}, () => Array(N).fill(0));
    current = null; path = [];
    stageLabel.textContent = `Stage ${stageIndex+1} · ${N}×${N}`;
    buildBoard(); render();
  }

  function undo(){
    if(path.length<=1){ // clear start if exists
      if(path.length===1){
        visited[path[0].r][path[0].c]=0;
      }
      current=null; path=[]; render(); return;
    }
    const last = path.pop();
    visited[last.r][last.c]=0;
    current = path[path.length-1];
    render();
  }

  // Warnsdorff heuristic auto-solver (greedy)
  function warnsdorffSolve(from){
    // if no start, choose a corner for better success on odd boards
    let cur = from || ( {r:0,c:0} );
    if(!from){ visited[cur.r][cur.c]=1; path=[{...cur}]; }

    const degree = (r,c)=>{
      let d=0; for(const [dr,dc] of knightMoves){
        const nr=r+dr, nc=c+dc; if(inBounds(nr,nc) && !visited[nr][nc]) d++;
      } return d;
    }

    while(path.length < N*N){
      let candidates=[];
      for(const [dr,dc] of knightMoves){
        const nr=cur.r+dr, nc=cur.c+dc;
        if(inBounds(nr,nc) && !visited[nr][nc]){
          candidates.push({r:nr,c:nc, deg:degree(nr,nc)});
        }
      }
      if(candidates.length===0) return false; // dead end
      candidates.sort((a,b)=> a.deg-b.deg || (Math.random()-0.5));
      const nxt = candidates[0];
      cur = {r:nxt.r, c:nxt.c};
      visited[cur.r][cur.c] = path.length+1;
      path.push({...cur});
    }
    current = {...path[path.length-1]};
    return true;
  }

  function autoComplete(){
    if(!current){
      // choose an okay starting square heuristically for success ratio
      current = {r: (N%2? Math.floor(N/2):1), c: (N%2? 0:1)};
      visited[current.r][current.c]=1; path=[{...current}];
    }
    // try greedy multiple times with slight randomization for robustness
    const snapshot = visited.map(row=>row.slice());
    const start = {...current};
    for(let tries=0; tries<120; tries++){
      // reset to snapshot
      for(let r=0;r<N;r++) for(let c=0;c<N;c++) visited[r][c]=snapshot[r][c];
      path = [];
      const startCell = visited[start.r][start.c] ? start : start; // keep same start
      if(!visited[startCell.r][startCell.c]){ visited[startCell.r][startCell.c]=1; }
      path=[{...startCell}];
      current={...startCell};

      // randomize move order a bit each attempt
      knightMoves.sort(()=>Math.random()-0.5);
      const ok = warnsdorffSolve(startCell);
      if(ok){ render(); return true; }
    }
    render();
    return false;
  }

  // Buttons
  btnReset.addEventListener('click', newGame);
  btnUndo.addEventListener('click', undo);
  btnSolve.addEventListener('click', ()=>{ const ok = autoComplete(); showToast(ok? '자동 완성 완료!':'완성에 실패했어요. 다시 시도하세요.'); });
  btnNext.addEventListener('click', ()=>{ if(stageIndex<stages.length-1){ stageIndex++; newGame(); } });

  // Keyboard: cheat sequence (₩ then Enter within 1.5s)
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Backquote'){ // ₩ / `
      cheatArmed = true;
      clearTimeout(cheatTimer);
      cheatTimer = setTimeout(()=> cheatArmed=false, 1500);
    } else if(e.key === 'Enter' && cheatArmed){
      cheatArmed=false; clearTimeout(cheatTimer);
      showToast('치트 활성화! 자동 완성 중…');
      setTimeout(()=>{ const ok = autoComplete(); if(!ok) showToast('치트 실패 😵 다시 시도!'); }, 50);
    }
  }, {passive:true});

  // init only the start overlay; actual board builds after start
  // (keeps first paint light)
})();
</script>
</body>
</html>
